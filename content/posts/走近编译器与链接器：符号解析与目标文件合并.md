---
date: 2025-11-04T17:23:49+08:00
title: 走近编译器与链接器：符号解析与目标文件合并
description: 走近编译器与链接器：符号解析与目标文件合并
featured_image: /images/book.png
images:
  - /images/book.png
tags:
  - tutorial
  - compile
categories: Tutorials
---
## 一、引言

在 C/C++ 编译过程中，**链接阶段**是将多个目标文件与库文件合并生成可执行文件的关键步骤。  
许多开发者在链接阶段遇到 “undefined reference” 或符号冲突问题，本篇文章将系统介绍链接器的工作原理，并演示相关工具的使用。

---

## 二、目标文件与符号

目标文件（`.o`）是汇编代码汇编后的产物，包含：

- **代码段**（`.text`）
    
- **只读数据段**（`.rodata`）
    
- **全局已初始化数据段**（`.data`）
    
- **未初始化数据段**（`.bss`）
    
- **符号表**（用于标识函数和变量）
    

示例程序：

```c
// foo.c
void foo() {}

// main.c
int main() { foo(); }
```

分别编译：

```bash
gcc -c foo.c
gcc -c main.c
```

使用 `nm` 查看符号表：

```bash
nm foo.o
```

输出示例：

```
0000000000000000 T foo
```

```bash
nm main.o
```

输出示例：

```
                 U foo
0000000000000000 T main
```

解释：

- `T`：符号在 `.text` 段定义
    
- `U`：未定义符号，需要链接器解析
    

---

## 三、链接器的功能

链接器主要完成以下工作：

1. **符号解析**
    
    - 将未定义符号与对应的定义符号匹配。
        
2. **地址分配**
    
    - 为每个段和符号分配最终的内存地址。
        
3. **重定位**
    
    - 修正指令中函数或数据的地址引用。
        
4. **生成可执行文件**
    
    - 合并目标文件和库文件，输出 ELF 可执行文件或共享库。
        

---

## 四、静态链接与动态链接

### 1. 静态链接

静态链接将库函数直接嵌入可执行文件中。

构建静态库：

```bash
ar rcs libfoo.a foo.o
```

编译链接静态库：

```bash
gcc main.c -L. -lfoo -o app_static
```

- 可执行文件包含库函数的副本；
    
- 不依赖外部动态库，文件体积较大。
    

---

### 2. 动态链接

动态链接将库函数保留在共享库中，运行时由操作系统加载。

创建动态库：

```bash
gcc -shared -fPIC foo.c -o libfoo.so
```

编译链接动态库：

```bash
gcc main.c -L. -lfoo -o app_dynamic
ldd app_dynamic  # 查看动态库依赖
```

- 可执行文件较小；
    
- 支持库升级而无需重新编译主程序。
    

---

## 五、符号冲突与链接错误示例

1. **未定义符号**
    

```bash
gcc main.c -o app
# undefined reference to 'foo'
```

原因：调用的函数未在目标文件或库中定义。

2. **重复定义**
    

```c
// foo1.c
int x = 1;

// foo2.c
int x = 2;
```

```bash
gcc foo1.c foo2.c -o app
# multiple definition of 'x'
```

解决方法：使用 `extern` 声明全局变量，或将变量定义在单一目标文件中。

---

## 六、反汇编与符号分析工具

### 1. `objdump`

查看可执行文件的汇编代码：

```bash
objdump -d app_static
```

- 可以检查函数调用是否被正确链接；
    
- 查看内联函数是否已展开。
    

### 2. `readelf`

查看 ELF 文件符号表：

```bash
readelf -s app_static
```

- 检查函数和全局变量符号位置；
    
- 判断是否包含静态库符号。
    

### 3. `nm`

查看单个目标文件符号：

```bash
nm foo.o
```

- 区分 `T`（已定义）与 `U`（未定义）符号；
    
- 便于调试链接错误。
    

---

## 七、跨文件 `inline` 与弱符号

- C++ 中 `inline` 函数通常放在头文件，允许在多个目标文件中重复定义；
    
- 编译器会生成 **弱符号（weak symbol）**，链接器在合并时自动处理重复定义。
    

```c++
// foo.h
inline int square(int x) { return x * x; }
```

- 无需单独 `.cpp` 文件；
    
- 保留类型检查与作用域规则；
    
- 与宏相比，更安全、可调试。
    

---

## 八、总结

链接阶段是将多个目标文件和库文件组合为完整程序的关键步骤。核心概念包括：

- 符号解析与重定位；
    
- 静态链接与动态链接差异；
    
- 弱符号与 inline 函数处理；
    
- 工具链调试：`nm`、`objdump`、`readelf`、`ldd`。